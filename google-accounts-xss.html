<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="/styles/styles.css">
	<title>DOM-based XSS at accounts.google.com</title>
</head>
<body>
	<a href="/" style="position: absolute;
top: 10px; left: 10px; font-size: 150%;"> Home</a> 
	<div style="width: 55%; position: absolute; top: 40px; left: 200px;">
		<h1 style="font-size: xx-large;">DOM-based XSS at accounts.google.com</h1>

	<p> This universal DOM-based XSS was discovered accidentally; it is fortunate that the Google Ads customer ID is the same format as an American phone number. I opened Gmail to check my inbox, and the following popped up:</p> <br>


<img src="https://i.imgur.com/d369WNA.png" style="width: 100%;"><br>
 <p>I rushed to report it to avoid a duplicate, without even checking what was going on, as I thought the picture showed a Stored XSS in Gmail triggered by Google Ads rules; but the reality was something else.</p><br>

<h2>Why did it work?</h2>
<p> Because two things: google voice extension was installed and this text '444-555-4455  &#x3C;img src=x onerror=alert(1)&#x3E;' was in the inbox page.<br> after a couple of minutes, I realized that this XSS was triggered by Google Voice Extension, which could execute javascript anywhere and thus on accounts.google.com and facebook.com. </p><br>
<img src="https://i.imgur.com/Y1qEs87.png" style="width: 100%;"> <br>
<img src="https://i.imgur.com/OJsMuco.png" style="width: 100%;"> <br>

<p>I extracted the Google Voice source code to find out what the issue was. In the file contentscript.js, there was a function called Wg() that was responsible for the DOM XSS. </p><br>


<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">function</span> Wg(a) {
    <span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> b = <span style="color: #a31515">/(^|\s)((\+1\d{10})|((\+1[ \.])?\(?\d{3}\)?[ \-\.\/]{1,3}\d{3}[ \-\.]{1,2}\d{4}))(\s|$)/m</span>, c = document.evaluate(<span style="color: #a31515">&#39;.//text()[normalize-space(.) != &quot;&quot;]&#39;</span>, a, <span style="color: #0000ff">null</span>, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, <span style="color: #0000ff">null</span>), d = 0; d &lt; c.snapshotLength; d++) {
        a = c.snapshotItem(d);
        <span style="color: #0000ff">var</span> f = b.exec(a.textContent);
        <span style="color: #0000ff">if</span> (f &amp;&amp; f.length) {
            f = f[2];
            <span style="color: #0000ff">var</span> g = <span style="color: #a31515">&quot;gc-number-&quot;</span> + Ug,
                h = <span style="color: #a31515">&#39;&lt;span id=&quot;&#39;</span> + g + <span style="color: #a31515">&#39;&quot; class=&quot;gc-cs-link&quot;title=&quot;Call with Google Voice&quot;&gt;&#39;</span> + f + <span style="color: #a31515">&quot;&lt;/span&gt;&quot;</span>,
                k;
            <span style="color: #0000ff">if</span> (k = a.parentNode &amp;&amp; !(a.parentNode.nodeName <span style="color: #0000ff">in</span> Og)) k = a.parentNode.className,
                k = <span style="color: #a31515">&quot;string&quot;</span> === <span style="color: #0000ff">typeof</span> k &amp;&amp; k.match(<span style="color: #a31515">/\S+/g</span>) || [], k = !Fa(k, <span style="color: #a31515">&quot;gc-cs-link&quot;</span>);
            <span style="color: #0000ff">if</span> (k) <span style="color: #0000ff">try</span> {
                <span style="color: #0000ff">if</span> (!document.evaluate(<span style="color: #a31515">&#39;ancestor-or-self::*[@googlevoice = &quot;nolinks&quot;]&#39;</span>, a, <span style="color: #0000ff">null</span>, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, <span style="color: #0000ff">null</span>)
                    .snapshotLength) {
                    <span style="color: #0000ff">if</span> (0 == a.parentNode.childElementCount) {
                        <span style="color: #0000ff">var</span> w = a.parentNode.innerHTML,
                            y = w.replace(f, h);
                        a.parentNode.innerHTML = y
                    } <span style="color: #0000ff">else</span> {
                        w = a.data;
                        y = w.replace(f, h);
                        <span style="color: #0000ff">var</span> u = Qc(<span style="color: #a31515">&quot;SPAN&quot;</span>);
                        u.innerHTML = y;
                        h = u;
                        k = a;
                        v(<span style="color: #0000ff">null</span> != h &amp;&amp; <span style="color: #0000ff">null</span> != k, <span style="color: #a31515">&quot;goog.dom.insertSiblingAfter expects non-null arguments&quot;</span>);
                        k.parentNode &amp;&amp; k.parentNode.insertBefore(h,
                            k.nextSibling);
                        Vc(a)
                    }
                    <span style="color: #0000ff">var</span> t = Ic(document, g);
                    t &amp;&amp; (Ug++, nc(t, <span style="color: #a31515">&quot;click&quot;</span>, ma(Sg, t, f)))
                }
            } <span style="color: #0000ff">catch</span> (E) {}
        }
    }
}
</pre></div>



	<p> The function wasn't difficult to read. The developer was looking for a phone number within the content of the body's elements, grabbing it, and then creating a new <span> element with the grabbed phone number as its content. This feature allows the user to click and call that number directly from the webpage.<br>
Let's break it down: from line 1 to line 9, the code uses document.evaluate to loop through the body's elements' contents. document.evaluate is a method that allows searching within an HTML or XML document, returning an XPathResult object. Here, it was meant to evaluate and grab all the body's elements' contents—specifically, to select all text nodes from the current node and assign them to the variable a. This was the source of the issue. Note here that this was a DOM XPath-injection<br>
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="color: #0000ff">var</span> b = <span style="color: #a31515">/(^|\s)((\+1\d{10})|((\+1[ \.])?\(?\d{3}\)?[ \-\.\/]{1,3}\d{3}[ \-\.]{1,2}\d{4}))(\s|$)/m</span>, c = document.evaluate(<span style="color: #a31515">&#39;.//text()[normalize-space(.) != &quot;&quot;]&#39;</span>, a, <span style="color: #0000ff">null</span>, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, <span style="color: #0000ff">null</span>), d = 0; d &lt; c.snapshotLength; d++) {
        a = c.snapshotItem(d);
</pre></div>

<br>
<p>The code then executes a search (using variable b, which is a regex for the American phone number format) for a match within the returned result stored in variable a. If a match is found, it is assigned to variable f and then placed as the content of a &#x3C;span&#x3E; element in variable h.

Lines 10 and 11 check the tag name of the HTML element from which variable f got its content. It ensures the tag is neither SCRIPT, STYLE, HEAD, OBJECT, TEXTAREA, INPUT, SELECT, nor A, and also ensures it doesn't have a class attribute named "gc-cs-link". This checking serves two main purposes:

Preventing DOM Interference: It stops the extension from manipulating the DOM where it's not intended, such as elements like SCRIPT, STYLE, and HEAD, or elements where adding a clickable number is not relevant, like INPUT or SELECT.

Preventing Infinite Looping: It prevents the script from creating the &#x3C;span&#x3E; element with the phone number again if it already exists, effectively stopping infinite loop scenarios.

From line 12 to line 27, there is an if condition: if variable k is true (meaning no element with the class attribute "gc-cs-link" has been found), it executes a try statement. Inside the try statement, another if condition checks—again using document.evaluate—if there is no element with the attribute googlevoice and the value nolinks. A final nested if condition then checks if variable a has no child elements. This is where the sink occurs:"</p><br>

<p>
	From line 12 to line 27, there is an if condition, if variable k is true, means no element with a class attribute name of "gc-cs-link" has been found, it will execute a try statement, another an if condition inside the try statement check, if there is nowhere an element with a "googlevoice" attribute and "nolinks" as its value can be found, again using the document.evaluate, then nested if condition check if the variable 'a'  has no child elements, and here is where the sink happens: <br>
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">w = a.parentNode.innerHTML,
y = w.replace(f, h);
a.parentNode.innerHTML = y
</pre></div>

</p>



<br>
<p>
This occurs if variable a has no child elements; otherwise, it executes the next statement, where the sink occurs again in the following line: <br>
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">k.parentNode &amp;&amp; k.parentNode.insertBefore(h, k.nextSibling);
</pre></div>
</p>
<br>


</p>

<h2>The fix: </h2>
  	
	<p> 
		I believe the developer intended to execute variable f, which was holding the phone number value (for example, +12223334455), on the sinks (innerHTML, insertBefore). Instead, for reasons I couldn't understand, they executed variable a, which was holding the payload (e.g., '444-555-4455  &#x3C;img src=x onerror=alert(1)&#x3E;' ) on the sinks. This XSS could have been avoided if they had not done so.
		
 
</p><br>

<h2>Reward: </h2>$3,133.7



	</div>
	<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

<div name="googleAds">
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3618089236298710"
     crossorigin="anonymous"></script>
<!-- security blog -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3618089236298710"
     data-ad-slot="9982666802"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
</body>
</html>
